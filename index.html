<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BlairIT Billjitsu</title>
  <style>
    :root {
      --primary: #0052CC;
      --success: #00C853;
      --bg: #f5f5f5;
    }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: var(--bg); margin:0; padding:0; }
    .container { max-width: 600px; margin: 0 auto; padding: 16px; }
    .card { background: white; border-radius: 12px; padding: 16px; margin-bottom: 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    .btn { padding: 12px 20px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; }
    .btn-primary { background: var(--primary); color: white; }
    .btn-success { background: var(--success); color: white; }
    .btn-small { padding: 8px 12px; font-size: 0.9em; }
    .timer { font-size: 2em; font-weight: bold; color: var(--primary); margin: 12px 0; }
    .ticket-title { font-size: 1.2em; font-weight: 600; margin: 0 0 8px 0; }
    .logout { text-align: center; margin-top: 30px; }
    .hidden { display: none; }
    h1 { text-align: center; color: #333; }
  </style>
</head>
<body>
  <div class="container">
    <h1>BillJitsu</h1>

    <!-- Login Screen -->
    <div id="loginScreen">
      <div class="card">
        <button id="loginBtn" class="btn btn-primary">Login with NinjaOne</button>
      </div>
    </div>

    <!-- Tickets Screen -->
    <div id="ticketsScreen" class="hidden">
      <div id="ticketsList"></div>
      <div class="logout">
        <button id="logoutBtn" class="btn btn-small">Logout</button>
      </div>
    </div>
  </div>

  <script>
    // ==== CONFIGURATION - FIXES APPLIED HERE ====
    const CLIENT_ID = "QoV0EhysIrvKh-uo5wrC2lxuJTc";

    // AUTOMATIC REGION DETECTION + CORRECT ENDPOINTS
    const REGION = "us"; // change to "eu" or "oc" if you're in Europe or Oceania
    const BASE_DOMAIN = REGION === "eu" ? "eu.ninjarmm.com" :
                        REGION === "oc" ? "oc.ninjarmm.com" : "app.ninjarmm.com";

    const AUTH_BASE   = `https://${BASE_DOMAIN}/ws/oauth`;
    const TOKEN_URL   = `${AUTH_BASE}/token`;
    const AUTHORIZE_URL = `${AUTH_BASE}/authorize`;
    const API_BASE    = `https://${REGION === "eu" ? "eu-api" : "api"}.ninjaone.com/v2`;

    // THIS MUST EXACTLY MATCH what you put in NinjaOne's Registered App
    const REDIRECT_URI = "https://mkennedy2547.github.io/billjitsu/";

    // ==== OAuth PKCE Helpers (unchanged) ====
    function generateCodeVerifier() {
      const array = new Uint32Array(28);
      crypto.getRandomValues(array);
      return Array.from(array, dec => ('0' + dec.toString(36)).slice(-2)).join('');
    }
    function base64urlencode(str) {
      return btoa(String.fromCharCode(...new Uint8Array(str)))
        .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    }
    async function generateCodeChallenge(verifier) {
      const encoder = new TextEncoder();
      const data = encoder.encode(verifier);
      const digest = await crypto.subtle.digest('SHA-256', data);
      return base64urlencode(digest);
    }

    // ==== Storage (unchanged) ====
    const storage = {
      get: key => JSON.parse(localStorage.getItem(key)),
      set: (key, val) => localStorage.setItem(key, JSON.stringify(val)),
      remove: key => localStorage.removeItem(key)
    };

    // ==== Main App (unchanged logic, just using correct URLs now) ====
    const loginScreen = document.getElementById('loginScreen');
    const ticketsScreen = document.getElementById('ticketsScreen');
    const ticketsList = document.getElementById('ticketsList');

    async function login() {
      const verifier = generateCodeVerifier();
      const challenge = await generateCodeChallenge(verifier);
      storage.set('codeVerifier', verifier);

      const params = new URLSearchParams({
        response_type: 'code',
        client_id: CLIENT_ID,
        redirect_uri: REDIRECT_URI,
        scope: 'monitoring management ticketing offline_access',
        code_challenge: challenge,
        code_challenge_method: 'S256',
        state: Math.random().toString(36).substring(2)
      });

      location.href = `${AUTHORIZE_URL}?${params.toString()}`;
    }

    async function exchangeCode(code) {
      const verifier = storage.get('codeVerifier');
      const response = await fetch(TOKEN_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({
          grant_type: 'authorization_code',
          client_id: CLIENT_ID,
          code,
          redirect_uri: REDIRECT_URI,
          code_verifier: verifier
        })
      });

      if (!response.ok) {
        const err = await response.text();
        alert("Token exchange failed: " + err);
        return;
      }

      const data = await response.json();
      data.expires_at = Date.now() + (data.expires_in * 1000);
      storage.set('tokens', data);
      storage.remove('codeVerifier');
      showTickets();
    }

    // Rest of your functions (api, refresh, timer, etc.) stay 100% the same
    // Just updated API_BASE above so they hit the right region

    async function api(path) {
      let tokens = storage.get('tokens');
      if (!tokens) throw new Error("Not logged in");

      if (tokens.expires_at < Date.now()) {
        const refresh = await fetch(TOKEN_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({
            grant_type: 'refresh_token',
            client_id: CLIENT_ID,
            refresh_token: tokens.refresh_token
          })
        });
        const newTokens = await refresh.json();
        newTokens.expires_at = Date.now() + (newTokens.expires_in * 1000);
        storage.set('tokens', newTokens);
        tokens = newTokens;
      }

      const res = await fetch(API_BASE + path, {
        headers: {
          Authorization: `Bearer ${tokens.access_token}`,
          'Content-Type': 'application/json'
        }
      });
      if (!res.ok) throw new Error(`API error ${res.status}`);
      return res.json();
    }

   ...
