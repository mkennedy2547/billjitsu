<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>NinjaOne Ticket Timer</title>
  <style>
    :root {
      --primary: #0052CC;
      --success: #00C853;
      --bg: #f5f5f5;
    }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: var(--bg); margin:0; padding:0; }
    .container { max-width: 600px; margin: 0 auto; padding: 16px; }
    .card { background: white; border-radius: 12px; padding: 16px; margin-bottom: 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    .btn { padding: 12px 20px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; }
    .btn-primary { background: var(--primary); color: white; }
    .btn-success { background: var(--success); color: white; }
    .btn-small { padding: 8px 12px; font-size: 0.9em; }
    .timer { font-size: 2em; font-weight: bold; color: var(--primary); margin: 12px 0; }
    .ticket-title { font-size: 1.2em; font-weight: 600; margin: 0 0 8px 0; }
    .logout { text-align: center; margin-top: 30px; }
    .hidden { display: none; }
    h1 { text-align: center; color: #333; }
  </style>
</head>
<body>
  <div class="container">
    <h1>NinjaOne Ticket Timer</h1>

    <!-- Login Screen -->
    <div id="loginScreen">
      <div class="card">
        <button id="loginBtn" class="btn btn-primary">Login with NinjaOne</button>
      </div>
    </div>

    <!-- Tickets Screen -->
    <div id="ticketsScreen" class="hidden">
      <div id="ticketsList"></div>
      <div class="logout">
        <button id="logoutBtn" class="btn btn-small">Logout</button>
      </div>
    </div>
  </div>

  <script>
    // ==== CONFIGURATION ====
    const CLIENT_ID = "QoV0EhysIrvKh-uo5wrC2lxuJTc";
    const REDIRECT_URI = location.href.split('?')[0]; // current page
    const AUTH_URL = "https://auth.ninjaone.com";
    const API_BASE = "https://api.ninjaone.com/v2";

    // ==== OAuth PKCE Helpers ====
    function generateCodeVerifier() {
      const array = new Uint32Array(28);
      crypto.getRandomValues(array);
      return Array.from(array, dec => ('0' + dec.toString(36)).slice(-2)).join('');
    }
    function base64urlencode(str) {
      return btoa(String.fromCharCode(...new Uint8Array(str)))
        .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    }
    async function generateCodeChallenge(verifier) {
      const encoder = new TextEncoder();
      const data = encoder.encode(verifier);
      const digest = await crypto.subtle.digest('SHA-256', data);
      return base64urlencode(digest);
    }

    // ==== Storage ====
    const storage = {
      get: key => JSON.parse(localStorage.getItem(key)),
      set: (key, val) => localStorage.setItem(key, JSON.stringify(val)),
      remove: key => localStorage.removeItem(key)
    };

    // ==== Main App ====
    const loginScreen = document.getElementById('loginScreen');
    const ticketsScreen = document.getElementById('ticketsScreen');
    const ticketsList = document.getElementById('ticketsList');

    async function login() {
      const verifier = generateCodeVerifier();
      const challenge = await generateCodeChallenge(verifier);
      storage.set('codeVerifier', verifier);

      const params = new URLSearchParams({
        response_type: 'code',
        client_id: CLIENT_ID,
        redirect_uri: REDIRECT_URI,
        scope: 'monitoring management ticketing offline_access',
        code_challenge: challenge,
        code_challenge_method: 'S256',
        state: Math.random().toString(36)
      });

      location.href = `${AUTH_URL}/oauth/authorize?${params}`;
    }

    async function exchangeCode(code) {
      const verifier = storage.get('codeVerifier');
      const response = await fetch(`${AUTH_URL}/oauth/token`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({
          grant_type: 'authorization_code',
          client_id: CLIENT_ID,
          code,
          redirect_uri: REDIRECT_URI,
          code_verifier: verifier
        })
      });
      const data = await response.json();
      if (data.access_token) {
        storage.set('tokens', data);
        storage.remove('codeVerifier');
        showTickets();
      }
    }

    async function api(path) {
      let tokens = storage.get('tokens');
      if (!tokens) throw new Error("Not logged in");

      // Refresh if needed
      if (tokens.expires_at < Date.now()) {
        const refresh = await fetch(`${AUTH_URL}/oauth/token`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({
            grant_type: 'refresh_token',
            client_id: CLIENT_ID,
            refresh_token: tokens.refresh_token
          })
        });
        tokens = await refresh.json();
        tokens.expires_at = Date.now() + (tokens.expires_in * 1000);
        storage.set('tokens', tokens);
      }

      const res = await fetch(API_BASE + path, {
        headers: {
          Authorization: `Bearer ${tokens.access_token}`,
          'Content-Type': 'application/json'
        }
      });
      if (!res.ok) throw new Error(`API error ${res.status}`);
      return res.json();
    }

    async function loadTickets() {
      const tickets = await api('/ticketing/tickets?status=Open');
      const myTickets = tickets.filter(t => 
        t.assignee?.email?.toLowerCase() === storage.get('userEmail')?.toLowerCase()
      );
      return myTickets.sort((a,b) => b.id - a.id);
    }

    function formatTime(seconds) {
      const h = Math.floor(seconds / 3600).toString().padStart(2,'0');
      const m = Math.floor((seconds % 3600)/60).toString().padStart(2,'0');
      const s = (seconds % 60).toString().padStart(2,'0');
      return `${h}:${m}:${s}`;
    }

    function startTimer(ticketId) {
      const timers = storage.get('timers') || {};
      if (timers.active === ticketId) return; // already running

      // Stop any previous
      if (timers.active) stopTimer();

      timers[ticketId] = timers[ticketId] || {total: 0, start: null};
      timers[ticketId].start = Date.now();
      timers.active = ticketId;
      storage.set('timers', timers);
      updateDisplay(ticketId);
    }

    function stopTimer() {
      const timers = storage.get('timers') || {};
      if (!timers.active) return;

      const elapsed = Math.floor((Date.now() - timers[timers.active].start) / 1000);
      timers[timers.active].total += elapsed;
      timers[timers.active].start = null;
      delete timers.active;
      storage.set('timers', timers);
    }

    function updateDisplay(activeId) {
      document.querySelectorAll('.timer').forEach(el => {
        const ticketId = parseInt(el.dataset.ticketId);
        const timers = storage.get('timers') || {};
        const data = timers[ticketId] || {total: 0, start: null};
        let seconds = data.total;
        if (data.start && ticketId === activeId) {
          seconds += Math.floor((Date.now() - data.start) / 1000);
        }
        el.textContent = formatTime(seconds);
      });
    }

    async function logTime(ticketId, minutes) {
      const tokens = storage.get('tokens');
      await fetch(API_BASE + `/ticketing/tickets/${ticketId}/timeentries`, {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${tokens.access_token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          minutes: minutes,
          description: "Time tracked via mobile timer"
        })
      });
      alert(`Logged ${minutes} minutes to ticket #${ticketId}`);
    }

    function renderTickets(tickets) {
      const timers = storage.get('timers') || {};
      ticketsList.innerHTML = tickets.map(ticket => {
        const data = timers[ticket.id] || {total: 0, start: null};
        const isRunning = timers.active == ticket.id;
        const seconds = data.total + (isRunning ? Math.floor((Date.now() - data.start)/1000) : 0);

        return `
          <div class="card">
            <div class="ticket-title">#${ticket.id} – ${ticket.title}</div>
            <div style="color:#666;font-size:0.9em;margin-bottom:8px;">
              ${ticket.customer?.name || 'No customer'} • Created ${new Date(ticket.created).toLocaleDateString()}
            </div>
            <div class="timer" data-ticket-id="${ticket.id}">${formatTime(seconds)}</div>
            <div>
              ${isRunning 
                ? `<button class="btn btn-small" onclick="stopTimer();updateDisplay()">Stop</button>`
                : `<button class="btn btn-primary btn-small" onclick="startTimer(${ticket.id});updateDisplay(${ticket.id})">Start Timer</button>`
              }
              <button class="btn btn-success btn-small" style="margin-left:8px;" 
                onclick="if(confirm('Log current time to ticket?')) { const mins = Math.floor(${seconds}/60); logTime(${ticket.id}, mins); }">
                Log Time
              </button>
            </div>
          </div>`;
      }).join('');

      // Start interval for live updating
      if (timers.active) {
        clearInterval(window.timerInterval);
        window.timerInterval = setInterval(() => updateDisplay(timers.active), 1000);
      }
    }

    async function showTickets() {
      loginScreen.classList.add('hidden');
      ticketsScreen.classList.remove('hidden');

      // Get user email once
      if (!storage.get('userEmail')) {
        const user = await api('/account/users/me');
        storage.set('userEmail', user.email);
      }

      const tickets = await loadTickets();
      renderTickets(tickets);
    }

    // ==== Event Listeners ====
    document.getElementById('loginBtn').onclick = login;
    document.getElementById('logoutBtn').onclick = () => {
      storage.remove('tokens');
      storage.remove('timers');
      storage.remove('userEmail');
      location.reload();
    };

    // ==== On Load ====
    if (location.search.includes('code=')) {
      const code = new URLSearchParams(location.search).get('code');
      history.replaceState(null, '', location.pathname);
      exchangeCode(code);
    } else if (storage.get('tokens')) {
      showTickets();
    }

    // Make functions global for onclick
    window.startTimer = startTimer;
    window.stopTimer = stopTimer;
    window.updateDisplay = updateDisplay;
    window.logTime = logTime;
  </script>
</body>

</html>
